# visualize_solution.py
"""
Visualizes the solution graph generated by the Steiner Forest solver
on the BDO map.

Edit the 'subgraph' entries at the bottom of the file.
"""

import branca
import folium
import webbrowser
import os
import tempfile
import folium.map
import rustworkx as rx
from folium.plugins import FeatureGroupSubGroup, GroupedLayerControl

import data_store as ds
from api_common import get_clean_exploration_data, SUPER_ROOT
from api_exploration_graph import get_exploration_graph
from api_rx_pydigraph import inject_super_root, set_graph_terminal_sets_attribute


TILE_SCALE = 12800

MARKER_COLORS = [
    "blue",
    "gray",
    "lightred",
    "purple",
    "red",
    "lightblue",
    "lightgray",
    "black",
    # "white",
    "lightgreen",
    "green",
    "darkred",
    "darkblue",
    "cadetblue",
    "pink",
    "darkgreen",
    "darkpurple",
    "beige",
    "orange",
]

# Color Constants
MAIN_GRAPH_EDGE_COLOR = "darkturquoise"
SUBGRAPH_EDGE_COLOR = "yellow"
SUBGRAPH_OPTIMAL_EDGE_COLOR = "red"
MAIN_OPTIMAL_EDGE_COLOR = "yellow"
BASE_TOWN_COLOR = "green"
REGULAR_NODE_COLOR = "lightgray"
SUPER_ROOT_COLOR = "red"

# Line Thicknesses
MAIN_GRAPH_EDGE_WEIGHT = 1
SUBGRAPH_EDGE_WEIGHT = 6
MAIN_OPTIMAL_EDGE_WEIGHT = 6
SUBGRAPH_OPTIMAL_EDGE_WEIGHT = 2


def add_edges_from_graph(
    fg: folium.FeatureGroup,
    graph: rx.PyGraph | rx.PyDiGraph,
    color: str | None = None,
    weight: float = 0.75,
):
    """Add edges from the graph to the map."""
    for u_index, v_index in graph.edge_list():
        # Only include one edge of a bidirectional connection.
        if u_index > v_index and not graph.has_edge(v_index, u_index):
            continue

        u_node = graph[u_index]
        v_node = graph[v_index]
        if u_node["waypoint_key"] == 99999 or v_node["waypoint_key"] == 99999:
            continue

        start = u_node["position"]
        end = v_node["position"]

        start_lat = start["z"] / TILE_SCALE
        start_lng = start["x"] / TILE_SCALE
        end_lat = end["z"] / TILE_SCALE
        end_lng = end["x"] / TILE_SCALE

        folium.PolyLine(
            locations=[
                (start_lat, start_lng),
                (end_lat, end_lng),
            ],
            color=color,
            weight=weight,
            opacity=1,
            popup=f"Edge: {u_node['waypoint_key']} - {v_node['waypoint_key']}",
            tooltip=f"Edge: {u_node['waypoint_key']} - {v_node['waypoint_key']}",
            **{"interactive": True, "bubblingMouseEvents": True},
        ).add_to(fg)


def add_node_markers_from_graph(fg: folium.FeatureGroup, graph: rx.PyGraph | rx.PyDiGraph):
    """Add markers for each node in the main graph."""
    for node in graph.nodes():
        node_color = None  # Reset the color for each node
        node_key = node["waypoint_key"]
        cost = node["need_exploration_point"]

        lng = node["position"]["x"] / TILE_SCALE  # Scaled coordinates
        lat = node["position"]["z"] / TILE_SCALE  # Scaled coordinates

        popup_text = f"Node Key: {node_key}, Cost: {cost}"

        if node_key == 99999:
            popup_text += " (Super Root)"
            node_color = SUPER_ROOT_COLOR

        if node_color is None:
            if node["is_base_town"]:
                node_color = BASE_TOWN_COLOR
            else:
                node_color = REGULAR_NODE_COLOR

        folium.CircleMarker(
            location=(lat, lng),
            radius=1 if not node["is_base_town"] else 4,
            color=node_color,
            fill=True,
            fill_color=node_color,
            popup=popup_text,
            tooltip=popup_text,
        ).add_to(fg)


def add_terminal_sets_markers(
    m: folium.Map, graph: rx.PyGraph | rx.PyDiGraph
) -> tuple[dict[str, FeatureGroupSubGroup], folium.FeatureGroup | None]:
    """Add terminal sets using FeatureGroupSubGroup for hierarchical toggling."""
    if "terminal_sets" not in graph.attrs:
        print("Warning: terminal_sets attribute not found in graph.")
        return {}, None

    terminal_sets = graph.attrs["terminal_sets"]

    # As the name indicates, this is the master FeatureGroup for the terminals layer.
    fg_terminal_sets_master = folium.FeatureGroup(name="All Terminal Sets", show=True).add_to(m)
    assert isinstance(fg_terminal_sets_master, folium.FeatureGroup)

    terminal_set_feature_groups = {}

    for color_index, (root, terminal_set) in enumerate(terminal_sets.items()):
        layer_name = f"Terminal Set {chr(65 + color_index)}"
        # FeatureGroupSubGroup nests the terminal set under the master group
        fg_terminal_set = FeatureGroupSubGroup(fg_terminal_sets_master, name=layer_name, show=True).add_to(m)
        terminal_set_feature_groups[layer_name] = fg_terminal_set

        terminal_set_color = MARKER_COLORS[color_index % len(MARKER_COLORS)]

        # Root node marker setup
        root_node = graph[root]
        root_lng = root_node["position"]["x"] / TILE_SCALE
        root_lat = root_node["position"]["z"] / TILE_SCALE

        folium.Marker(
            location=(root_lat, root_lng),
            icon=folium.Icon(
                color=terminal_set_color,
                icon=f"{chr(97 + color_index)}",
                prefix="fa",
                extraClasses="fa-border",
            ),
            popup=f"Root Node Key: {root_node['waypoint_key']}, Cost: {root_node['need_exploration_point']}",
            tooltip=f"Root Node Key: {root_node['waypoint_key']}, Cost: {root_node['need_exploration_point']}",
        ).add_to(fg_terminal_set)

        # Terminal node markers setup
        for terminal in terminal_set:
            terminal_node = graph[terminal]
            terminal_lng = terminal_node["position"]["x"] / TILE_SCALE
            terminal_lat = terminal_node["position"]["z"] / TILE_SCALE

            folium.Marker(
                location=(terminal_lat, terminal_lng),
                icon=folium.Icon(color=terminal_set_color, icon=f"{chr(97 + color_index)}", prefix="fa"),
                popup=f"Terminal Node Key: {terminal_node['waypoint_key']}, Cost: {terminal_node['need_exploration_point']}",
                tooltip=f"Terminal Node Key: {terminal_node['waypoint_key']}, Cost: {terminal_node['need_exploration_point']}",
            ).add_to(fg_terminal_set)

    return terminal_set_feature_groups, fg_terminal_sets_master


def visualize_solution_graph(
    main_graph: rx.PyGraph | rx.PyDiGraph,
    subgraph: rx.PyGraph | rx.PyDiGraph | None = None,
):
    """
    Visualizes the game map with the solution graph.

    Args:
        main_graph (rx.PyGraph): The main graph.
        subgraph (rx.PyGraph, optional): The reduced subgraph. Defaults to None.
        true_optimal_nodes (rx.PyGraph, optional): The true optimal solution node list. Defaults to None.
        reduced_optimal_nodes (rx.PyGraph, optional): The reduced graph optimal solution node list. Defaults to None.
    """

    # This is the main map which provides the coordinate system for location and ui controls.
    m = folium.Map(
        crs="Simple",  # Don't change
        location=[0, 0],  # Don't change
        zoom_start=2,  # Don't change
        zoom_snap=0.25,
        tiles=None,
    )

    # The tiles need to be a pane fixed at the bottom layer for proper drawing layers.
    tile_pane = folium.map.CustomPane("tile_pane", z_index=1)
    m.add_child(tile_pane)

    # Don't change, the zoom levels are pretty critical on these tiles.
    tiles = os.path.join(ds.path(), "maptiles", "{z}", "{x}_{y}.webp")
    tile_layer = folium.TileLayer(
        name="BDO Router",
        attr="Map Tiles @ BDO",
        min_zoom=1,
        max_zoom=7,
        no_wrap=True,
        pane="tile_pane",
        show=True,
        tiles=tiles,
    )
    tile_layer.add_to(m)

    # These Feature Groups allow control of the UI elements and are used for the
    # z-order of the layers when we set the keep_in_front setting below.
    fg_all_nodes = folium.FeatureGroup(name="All Nodes", show=True)
    fg_main_graph_edges = folium.FeatureGroup(name="Main Graph Edges", show=True)
    fg_subgraph_edges = folium.FeatureGroup(name="Sub Graph Edges", show=True)
    fg_main_optimal_edges = folium.FeatureGroup(name="Main Graph Optimal Edges", show=True)
    fg_subgraph_optimal_edges = folium.FeatureGroup(name="Sub Graph Optimal Edges", show=True)

    # Only use nodes in the main_graph.
    # All other graphs have the same exploration nodes.
    add_node_markers_from_graph(fg_all_nodes, main_graph)

    # Add all given edges from each graph to their own feature group
    # for independent control.
    add_edges_from_graph(
        fg_main_graph_edges,
        main_graph,
        color=MAIN_GRAPH_EDGE_COLOR,
        weight=MAIN_GRAPH_EDGE_WEIGHT,
    )
    if subgraph is not None:
        add_edges_from_graph(
            fg_subgraph_edges,
            subgraph,
            color=SUBGRAPH_EDGE_COLOR,
            weight=SUBGRAPH_EDGE_WEIGHT,
        )

    # Terminal sets toggling is a bit trickier, see the called function
    # for more details but in short we have a master and independent controls.
    terminal_set_feature_groups, fg_terminal_sets_master = add_terminal_sets_markers(m, main_graph)
    assert fg_terminal_sets_master is not None

    # All Feature Groups are added to the map except the terminal groups which
    # got added in the add_terminal_sets_markers function.
    fg_all_nodes.add_to(m)
    fg_main_graph_edges.add_to(m)
    fg_subgraph_edges.add_to(m)
    fg_main_optimal_edges.add_to(m)
    fg_subgraph_optimal_edges.add_to(m)

    # NOTE: The keep_in_front order is critical!
    m.keep_in_front(
        fg_main_graph_edges,
        fg_subgraph_edges,
        fg_main_optimal_edges,
        fg_subgraph_optimal_edges,
        fg_all_nodes,
        fg_terminal_sets_master,
        *terminal_set_feature_groups.values(),
    )

    # Grouped Layer Control for everything except Terminal Sets which is
    # handled below as its own LayerControl.
    group_layer_control = GroupedLayerControl(
        groups={
            "Base": [fg_all_nodes, fg_main_graph_edges, fg_subgraph_edges],
            "Optimal": [fg_main_optimal_edges, fg_subgraph_optimal_edges],
        },
        exclusive_groups=False,
        collapsed=False,
    )

    # Add the LayerControl after the tile layer
    folium.LayerControl(collapsed=False).add_to(m)
    group_layer_control.add_to(m)

    # Add the graph stats to the map
    stats_html = f"""
        <div style="position:absolute; z-index:100000; left:10px; top:10px;
                    background-color:white; padding:10px; border:1px solid black;">
            <h2>Graph/Solution Stats</h2>
            <p>Main Graph Nodes: {len(main_graph.nodes())}</p>
            <p>Main Graph Edges: {len(main_graph.edge_list())}</p>"""
    if subgraph:
        stats_html += f"""
            <p>Sub Graph Nodes: {len(subgraph.nodes())}</p>
            <p>Sub Graph Edges: {len(subgraph.edge_list())}</p>"""
    stats_html += """
        </div>
    """
    root = m.get_root()
    if isinstance(root, branca.element.Figure):  # (mostly for Pylance)
        root.html.add_child(folium.Element(stats_html))

    tmp_dir = tempfile.gettempdir()
    map_file = os.path.join(tmp_dir, "bdo_map.html")
    m.save(map_file)
    print(f"Map saved to {map_file}. Opening in your browser...")
    webbrowser.open("file://" + map_file)


def visualize_with_terminals(
    main_graph: rx.PyGraph | rx.PyDiGraph,
    subgraph: rx.PyGraph | rx.PyDiGraph | None = None,
    terminals: dict[int, int] | None = None,
):
    """
    Visualizes the game map with the solution graph.

    Args:
        main_graph (rx.PyGraph): The main graph used for background layer.
        subgraph (rx.PyGraph, optional): The reduced subgraph. Defaults to None.)
        terminals (dict, optional): terminal, root mapping. Defaults to None.
    """
    # TODO: Write this up to be part of the pipeline
    pass


if __name__ == "__main__":
    """Example usage"""
    data = {}
    data["exploration"] = get_clean_exploration_data({})

    # Main graph (background)
    config = {}
    config["exploration_data"] = {"directed": True, "edge_weighted": False, "omit_great_ocean": True}
    G = get_exploration_graph(config)
    assert isinstance(G, rx.PyDiGraph)

    # MARK: Subgraph
    # fmt:off
    # indicate the {terminal: root, ... } pairs dict
    terminals={849: 1623, 160: 302, 1221: 1, 1206: 1314, 1085: 608, 911: 302, 835: 301, 1884: 1781, 475: 1141, 1908: 1850, 1686: 302, 171: 1319, 168: 61, 483: 1, 1082: 61, 1090: 604, 1816: 1795, 1914: 1002, 164: 1, 1892: 1795, 1072: 1649, 1684: 1649, 1083: 1649, 1717: 1002, 1907: 1843, 1502: 1101, 136: 1380}
    # indicate the solution nodes (paths to highlight)
    highlights = set([1, 2, 4, 5, 21, 22, 42, 43, 44, 45, 61, 64, 66, 136, 160, 164, 168, 171, 301, 302, 305, 306, 309, 324, 327, 341, 344, 346, 347, 371, 375, 475, 483, 601, 604, 608, 609, 621, 622, 626, 627, 632, 633, 634, 635, 652, 664, 675, 701, 702, 704, 709, 710, 712, 716, 719, 720, 721, 722, 723, 724, 725, 726, 835, 849, 911, 1002, 1010, 1014, 1015, 1018, 1020, 1021, 1053, 1056, 1061, 1062, 1063, 1064, 1072, 1082, 1083, 1085, 1090, 1101, 1136, 1138, 1140, 1141, 1148, 1161, 1164, 1206, 1221, 1301, 1302, 1303, 1304, 1305, 1306, 1312, 1313, 1314, 1315, 1317, 1318, 1319, 1321, 1327, 1328, 1329, 1330, 1339, 1343, 1375, 1379, 1380, 1502, 1618, 1619, 1621, 1622, 1623, 1630, 1649, 1656, 1659, 1664, 1665, 1666, 1668, 1684, 1686, 1704, 1705, 1717, 1718, 1781, 1793, 1795, 1797, 1798, 1816, 1843, 1844, 1845, 1849, 1850, 1858, 1860, 1870, 1874, 1875, 1884, 1892, 1907, 1908, 1914])
    # fmt:on

    if SUPER_ROOT in terminals.values():
        inject_super_root(config, G)
    set_graph_terminal_sets_attribute(G, terminals)
    highlights.update(key for key in terminals.keys())
    highlights.update(key for key in terminals.values())
    waypoint_to_index = {node["waypoint_key"]: i for i, node in enumerate(G.nodes())}
    highlight_indices = [waypoint_to_index[key] for key in highlights]
    highlight_graph = G.subgraph(highlight_indices)
    cost = sum(node["need_exploration_point"] for node in highlight_graph.nodes())
    print(f"Cost of highlighted nodes: {cost}")

    # # Generate web page using Folium - browser will open when complete.
    visualize_solution_graph(
        main_graph=G,
        subgraph=highlight_graph,
    )
